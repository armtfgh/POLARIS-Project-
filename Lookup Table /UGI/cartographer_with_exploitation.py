"""
cartographer_with_exploitation.py
==================================

Modified Cartographer with epsilon-greedy exploration strategy.

Instead of PURE exploration (always maximize variance), this version:
- With probability (1-epsilon): Explore (maximize variance)
- With probability epsilon: Exploit (maximize predicted yield)

This helps NDCG by focusing some samples on high-yield regions.
"""

from cartographer import Cartographer, load_lookup_csv_oracle
import torch
from torch import Tensor
from typing import Tuple
import numpy as np


class CartographerWithExploitation(Cartographer):
    """
    Epsilon-greedy exploration: occasionally exploit to focus on high-yield regions.
    """

    def __init__(self, *args, epsilon: float = 0.2, **kwargs):
        """
        Args:
            epsilon: Probability of exploitation (0.0 = pure exploration, 1.0 = pure exploitation)
        """
        super().__init__(*args, **kwargs)
        self.epsilon = float(epsilon)
        self.rng = np.random.RandomState(int(self.seed))

    def suggest(self, gp) -> Tuple[int, float]:
        """
        Epsilon-greedy selection:
        - With prob (1-epsilon): maximize variance (explore)
        - With prob epsilon: maximize predicted mean (exploit)
        """
        rem = [i for i in range(int(self.lookup.n)) if i not in self.seen]
        if len(rem) == 0:
            return -1, float("nan")

        X_pool = self.lookup.X[rem].to(device=self.device, dtype=self.dtype)

        with torch.no_grad():
            post = gp.posterior(X_pool.unsqueeze(1))
            var = post.variance.reshape(-1).clamp_min(1e-12)
            mean = post.mean.reshape(-1)

            # Epsilon-greedy decision
            if self.rng.rand() < self.epsilon:
                # EXPLOIT: select highest predicted mean
                j = int(torch.argmax(mean).item())
                score = float(mean[j].item())
                mode = "exploit"
            else:
                # EXPLORE: select highest uncertainty
                j = int(torch.argmax(var).item())
                score = float(torch.sqrt(var[j]).item())
                mode = "explore"

            return int(rem[j]), score


def run_comparison(epsilon_values=[0.0, 0.2, 0.5]):
    """
    Compare different epsilon values to see effect on knowledge extraction.
    """
    import pandas as pd
    from cartographer import run_cartographer_analyst_pipeline_improved

    results = {}

    for eps in epsilon_values:
        print(f"\n{'='*70}")
        print(f"Running with epsilon={eps:.1f} ({'pure exploration' if eps == 0 else f'{eps*100:.0f}% exploitation'})")
        print('='*70)

        # Create custom cartographer
        lookup = load_lookup_csv_oracle("ugi_merged_dataset.csv", objective_col="yield")
        cart = CartographerWithExploitation(
            lookup=lookup,
            seed=42,
            epsilon=eps,
            device=torch.device("cpu"),
            dtype=torch.double
        )

        # Run manually (simplified version of the pipeline)
        cart.initialize(n_init=6)
        for t in range(100):
            cart.step(iteration=t)

        hist_df = pd.DataFrame(cart.history)

        # Calculate metrics
        best_found = hist_df['best_so_far'].max()
        mean_yield = hist_df['y'].mean()
        top_10_mean = hist_df.nlargest(10, 'y')['y'].mean()

        results[eps] = {
            'best_found': best_found,
            'mean_yield': mean_yield,
            'top_10_mean': top_10_mean,
            'history': hist_df
        }

        print(f"Best yield found: {best_found:.4f}")
        print(f"Mean sampled yield: {mean_yield:.4f}")
        print(f"Top-10 samples mean: {top_10_mean:.4f}")

    print(f"\n{'='*70}")
    print("COMPARISON SUMMARY")
    print('='*70)
    print(f"{'Epsilon':<10} {'Best Found':<15} {'Mean Yield':<15} {'Top-10 Mean':<15}")
    print('-'*70)
    for eps in epsilon_values:
        r = results[eps]
        print(f"{eps:<10.1f} {r['best_found']:<15.4f} {r['mean_yield']:<15.4f} {r['top_10_mean']:<15.4f}")

    return results


if __name__ == "__main__":
    results = run_comparison(epsilon_values=[0.0, 0.1, 0.2, 0.3])

    # Plot comparison
    import matplotlib.pyplot as plt

    fig, axes = plt.subplots(2, 2, figsize=(14, 10))

    for idx, (eps, data) in enumerate(results.items()):
        ax = axes[idx // 2, idx % 2]
        hist = data['history']

        ax.plot(hist['iter'], hist['best_so_far'], linewidth=2, label='Best so far')
        ax.set_xlabel('Iteration')
        ax.set_ylabel('Best Yield Found')
        ax.set_title(f'Îµ = {eps:.1f} ({"pure exploration" if eps == 0 else f"{eps*100:.0f}% exploitation"})')
        ax.grid(True, alpha=0.3)
        ax.legend()

    plt.tight_layout()
    plt.savefig('epsilon_comparison.png', dpi=150)
    print("\nPlot saved to: epsilon_comparison.png")
    plt.show()
